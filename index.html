<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>VR Brain Confidence Trainer - Phase 1 Upgraded</title>
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      height: 100%;
      background: black;
      touch-action: none;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    #startBtn {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 20px 40px;
      font-size: 24px;
      background: green;
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      z-index: 10;
    }
    #stopBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 10px 20px;
      font-size: 16px;
      background: red;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      z-index: 10;
    }
  </style>
</head>
<body>
  <button id="startBtn">Start</button>
  <button id="stopBtn">Stop</button>
  <canvas id="vrCanvas"></canvas>

  <script>
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const canvas = document.getElementById('vrCanvas');
    const ctx = canvas.getContext('2d');
    let video, stream, audioCtx, oscillator, gainNode;
    let running = false;
    let confidence = 0; // 0=low, 1=high
    let targetConfidence = 0;
    let lastTime = Date.now();
    let wakeLock = null;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // --- Initialize Back Camera ---
    async function initCamera() {
      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { exact: "environment" }, width: { ideal: 1280 }, height: { ideal: 720 } },
          audio: false
        });
        video = document.createElement('video');
        video.srcObject = stream;
        video.play();
      } catch (err) {
        alert('Error accessing back camera: ' + err);
      }
    }

    // --- Initialize Sound ---
    function initSound() {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      oscillator = audioCtx.createOscillator();
      oscillator.type = 'sine';
      oscillator.frequency.setValueAtTime(220, audioCtx.currentTime); // Base tone
      gainNode = audioCtx.createGain();
      gainNode.gain.value = 0.01; // Very soft
      oscillator.connect(gainNode).connect(audioCtx.destination);
      oscillator.start();
    }

    // --- Request Wake Lock ---
    async function requestWakeLock() {
      try {
        wakeLock = await navigator.wakeLock.request('screen');
        wakeLock.addEventListener('release', () => console.log('Wake Lock released'));
      } catch (err) {
        console.error('Wake Lock error:', err);
      }
    }

    // --- Update Confidence & Sound ---
    function updateConfidence(deltaTime) {
      // Slowly move actual confidence toward targetConfidence
      const smoothing = 0.05; // smaller = slower, more stable
      confidence += (targetConfidence - confidence) * smoothing;

      // Map confidence to oscillator frequency and gain
      oscillator.frequency.setValueAtTime(220 + confidence*50, audioCtx.currentTime);
      gainNode.gain.setValueAtTime(0.01 + confidence*0.05, audioCtx.currentTime);
    }

    // --- Draw Illusions ---
    function drawIllusions() {
      if (!video) return;
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      // --- Radial Flow Illusion ---
      const flowRadius = canvas.width / 2;
      const now = Date.now();
      const elapsed = (now - lastTime) / 1000;
      lastTime = now;

      // Target confidence determines speed and opacity
      const flowSpeed = (1 - confidence) * 50; // faster when low confidence

      for (let i = 0; i < 60; i++) {
        const angle = (i / 60) * Math.PI * 2 + elapsed * flowSpeed * 0.1;
        const x = canvas.width/2 + Math.cos(angle) * flowRadius * 0.8;
        const y = canvas.height/2 + Math.sin(angle) * flowRadius * 0.8;
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, Math.PI*2);
        ctx.fillStyle = `rgba(0,255,0,${1-confidence})`; // fades as confidence grows
        ctx.fill();
      }
    }

    // --- Animation Loop ---
    function animate() {
      if (!running) return;
      const now = Date.now();
      const deltaTime = (now - lastTime) / 1000;

      // --- For demo: increase targetConfidence gradually if stable (10â€“15 sec to peak) ---
      targetConfidence += deltaTime / 15; // reach full confidence in 15 seconds
      if (targetConfidence > 1) targetConfidence = 1;

      updateConfidence(deltaTime);
      drawIllusions();
      requestAnimationFrame(animate);
    }

    // --- Start / Stop ---
    startBtn.onclick = async () => {
      await initCamera();
      initSound();
      running = true;
      startBtn.style.display = 'none';

      // Request fullscreen
      if (canvas.requestFullscreen) canvas.requestFullscreen();
      else if (canvas.webkitRequestFullscreen) canvas.webkitRequestFullscreen();
      else if (canvas.msRequestFullscreen) canvas.msRequestFullscreen();

      // Request wake lock
      requestWakeLock();

      animate();
    };

    stopBtn.onclick = () => {
      running = false;
      targetConfidence = 0;
      confidence = 0;
      if (stream) stream.getTracks().forEach(track => track.stop());
      if (oscillator) oscillator.stop();
      startBtn.style.display = 'block';
    };

    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });

    // Optional: release wake lock on page hide
    document.addEventListener('visibilitychange', () => {
      if (wakeLock !== null && document.hidden) {
        wakeLock.release();
        wakeLock = null;
      }
    });
  </script>
</body>
</html>
