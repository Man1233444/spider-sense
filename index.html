<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mobile AR Skeleton</title>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/examples/js/controls/OrbitControls.js"></script>

<style>
html,body{margin:0;padding:0;width:100%;height:100%;background:black;overflow:hidden;}
video{position:absolute;top:0;left:0;width:100vw;height:100vh;object-fit:cover;pointer-events:none;}
canvas{position:absolute;top:0;left:0;}
#start{position:fixed;top:0;left:0;width:100vw;height:100vh;display:flex;justify-content:center;align-items:center;background:black;color:white;font-size:36px;z-index:9999;cursor:pointer;}
#debug{position:fixed;top:10px;left:10px;color:lime;font-size:16px;z-index:10;}
</style>
</head>
<body>

<video id="video" autoplay playsinline></video>
<div id="start">TAP TO START</div>
<div id="debug">Initializing...</div>

<script>
// Elements
const startBtn = document.getElementById("start");
const debug = document.getElementById("debug");
const video = document.getElementById("video");

// --- Three.js ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight,0.1,1000);
const renderer = new THREE.WebGLRenderer({alpha:true});
renderer.setSize(window.innerWidth,window.innerHeight);
document.body.appendChild(renderer.domElement);
const light = new THREE.DirectionalLight(0xffffff,1); light.position.set(0,10,10); scene.add(light);
const controls = new THREE.OrbitControls(camera,renderer.domElement);
camera.position.set(0,1.5,3); controls.update();

// Skeleton
const joints = [], bones=[];
const jointGeo = new THREE.SphereGeometry(0.05,8,8);
const jointMat = new THREE.MeshStandardMaterial({color:0xffff00});
for(let i=0;i<33;i++){ const j=new THREE.Mesh(jointGeo,jointMat); scene.add(j); joints.push(j); }
const bonesIndices=[[0,1],[1,2],[2,3],[0,4],[4,5],[5,6],[11,13],[13,15],[12,14],[14,16],[11,23],[23,25],[25,27],[12,24],[24,26],[26,28]];
bonesIndices.forEach(([p,c])=>{const geom=new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(),new THREE.Vector3()]);const line=new THREE.Line(geom,new THREE.LineBasicMaterial({color:0xffff00}));scene.add(line);bones.push({line,p,c});});

// MediaPipe Pose
let pose = null; let lastLandmarks = [];

startBtn.addEventListener("click",async()=>{
  if(document.documentElement.requestFullscreen) await document.documentElement.requestFullscreen();
  startBtn.style.display="none";
  await startBackCamera();
});

async function startBackCamera(){
  debug.textContent="Looking for back cameraâ€¦";
  const devices = await navigator.mediaDevices.enumerateDevices();
  const backCam = devices.find(d=>d.kind==="videoinput" && d.label.toLowerCase().includes("back"));
  if(!backCam){debug.textContent="No back camera found!";return;}
  debug.textContent=`Back camera found: ${backCam.label}`;
  const stream = await navigator.mediaDevices.getUserMedia({video:{deviceId:{exact:backCam.deviceId},width:1280,height:720},audio:false});
  video.srcObject=stream;

  pose = new Pose({locateFile:file=>`https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
  pose.setOptions({modelComplexity:1,smoothLandmarks:true,minDetectionConfidence:0.5,minTrackingConfidence:0.5});
  pose.onResults(updateSkeleton);

  async function loop(){if(video.readyState>=2) await pose.send({image:video}); requestAnimationFrame(loop);}
  loop();
}

function updateSkeleton(results){
  if(!results.poseLandmarks) return;
  results.poseLandmarks.forEach((l,i)=>{
    if(l.visibility<0.5 && lastLandmarks[i]){
      // interpolate
      lastLandmarks[i]={x:lastLandmarks[i].x*0.8 + l.x*0.2,y:lastLandmarks[i].y*0.8 + l.y*0.2,z:lastLandmarks[i].z*0.8 + (l.z||0)*0.2};
    }else{lastLandmarks[i]=l;}
  });

  // Map to Three.js
  lastLandmarks.forEach((l,i)=>{
    const x=(l.x-0.5)*2; const y=-(l.y-0.5)*2; const z=-(l.z||0);
    joints[i].position.set(x,y,z);
  });

  bones.forEach(b=>{
    const p=joints[b.p].position; const c=joints[b.c].position;
    b.line.geometry.setFromPoints([p.clone(),c.clone()]);
    b.line.geometry.attributes.position.needsUpdate=true;
  });
}

// Render loop
function animate(){requestAnimationFrame(animate);renderer.render(scene,camera);controls.update();}
animate();
</script>

</body>
</html>
