<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Hand Line AR</title>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>

<style>
html, body {
  margin:0;
  padding:0;
  width:100%;
  height:100%;
  background:black;
  overflow:hidden;
}

#camera-container {
  position:absolute;
  top:0;
  left:0;
  width:100%;
  height:100%;
  z-index:0;
}

video, canvas {
  position:absolute;
  top:0;
  left:0;
  width:100%;
  height:100%;
  object-fit:cover;
  pointer-events:none;
}

#start {
  position:fixed;
  top:0;
  left:0;
  width:100vw;
  height:100vh;
  display:flex;
  justify-content:center;
  align-items:center;
  background:black;
  color:white;
  font-size:36px;
  z-index:9999;
  cursor:pointer;
  pointer-events:auto;
}
</style>
</head>
<body>

<div id="camera-container">
  <video id="video" autoplay playsinline></video>
  <canvas id="canvas"></canvas>
</div>

<div id="start">TAP TO START</div>

<script>
const startBtn = document.getElementById("start");
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let pose = null;

startBtn.addEventListener("click", async () => {
  if (document.documentElement.requestFullscreen) {
    await document.documentElement.requestFullscreen();
  }
  startBtn.style.display = "none";
  await startBackCamera();
});

async function startBackCamera() {
  const devices = await navigator.mediaDevices.enumerateDevices();
  const backCamera = devices.find(d => d.kind === "videoinput" && d.label.toLowerCase().includes("back"));
  if(!backCamera){ alert("No back camera found!"); return; }

  const stream = await navigator.mediaDevices.getUserMedia({
    video:{deviceId:{exact:backCamera.deviceId}, width:1280, height:720},
    audio:false
  });
  video.srcObject = stream;

  pose = new Pose({locateFile:file=>`https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
  pose.setOptions({modelComplexity:1,smoothLandmarks:true,minDetectionConfidence:0.5,minTrackingConfidence:0.5});
  pose.onResults(drawHandsLine);

  async function loop(){
    if(video.readyState>=2) await pose.send({image:video});
    requestAnimationFrame(loop);
  }
  loop();
}

function drawHandsLine(results){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  if(!results.poseLandmarks) return;

  const leftWrist = results.poseLandmarks[15]; // left wrist
  const rightWrist = results.poseLandmarks[16]; // right wrist

  if(!leftWrist || !rightWrist) return;

  const x1 = leftWrist.x * canvas.width;
  const y1 = leftWrist.y * canvas.height;
  const x2 = rightWrist.x * canvas.width;
  const y2 = rightWrist.y * canvas.height;

  // Draw line
  ctx.beginPath();
  ctx.moveTo(x1,y1);
  ctx.lineTo(x2,y2);
  ctx.strokeStyle = "lime";
  ctx.lineWidth = 5;
  ctx.stroke();

  // Check for “wall hit”
  const hitPoints = [];
  if(x1 <= 0 || x1 >= canvas.width || y1 <= 0 || y1 >= canvas.height) hitPoints.push({x:x1,y:y1});
  if(x2 <= 0 || x2 >= canvas.width || y2 <= 0 || y2 >= canvas.height) hitPoints.push({x:x2,y:y2});

  // Draw big red circles on hit points
  hitPoints.forEach(p=>{
    ctx.beginPath();
    ctx.arc(p.x,p.y,50,0,Math.PI*2);
    ctx.fillStyle="red";
    ctx.fill();
  });
}
</script>

</body>
</html>
